# Chapter3
* RxJava의 아키텍처는 옵저버(Observer) 패턴과 이터레이터(Iterator) 패턴의 영향을 받음

### 3.1 RxJava와 디자인 패턴
#### 3.1.1 옵저버 패턴
* GoF가 처음 제시한 디자인 패턴
* 관찰 대상 객체의 상태에 변화가 발생하면 객체를 관찰하는 객체가 변화에 따라 일련의 처리를 작업

| 클래스 | 설명 |
| :----- | :----- |
| Subject | 관찰 대상 클래스 (`생산자`) |
| Observer | 관찰자 인터페이스 (`소비자`) |
| ConcreteSubject | Subject를 상속한 클래스, 실제 관찰 대상 객체 |
| ConcreteObserver | Observer를 구현한 클래스, 실제 변화에 따른 처리 내용 구현 |

#### 3.1.2 이터레이터 패턴
* GoF가 처음 제시한 디자인 패턴
* 데이터 집합체(aggregate)에서 순서대로 데이터를 꺼내기 위한 패턴

* RxJava 비교
  * 차이점
    * Pull vs Push
      * 이터레이터 패턴 : 소비자가 데이터를 가져가는 Pull 방식
      * RxJava : 소비자에게 데이터를 통지하는 Push 방식
    * 통지 종료 시점
      * 이터레이터 패턴 : hasNext가 false일 경우
      * RxJava : 완료 및 에러 통지시
  * 공통점
    * 데이터를 하나씩 순서대로 처리하는 매커니즘

| 클래스 | 설명 |
| :----- | :----- |
| Aggregate | 데이터 집합체 인터페이스 |
| Iterator | 데이터를 순서대로 받기 위한 인터페이스 |
| ConcreteAggregate | Aggregate를 구현한 클래스, 실제 데이터 집합체 |
| ConcreteIterator | Iterator를 구현한 클래스, 실제 데이터를 받을 수 있게 구현 |
 
### 3.2 비동기 처리
* 비동기 처리 : 어떤 작업을 처리하는 도중에 다른 작업도 처리할 수 있는 방법
* 논리 프로세서가 여러 개 있는 멀티코어 CPU를 사용하는 환경에서 동시에 여러 처리 작업 실행
* RxJava는 생산자와 소비자의 작업을 비동기로 처리하며, 스레드 관리를 위한 클래스 제공

#### 3.2.1 RxJava에서 비동기 처리
* 기본적으로 생산자, 연산자 및 소비자가 같은 스레드에서 실행
* 비동기 처리 설정을 통해 생산자, 연산자 및 소비자의 처리 작업을 실행할 스레드 분리 가능

> 비동치 처리를 위해 생산자와 소비자는 논리적으로 분리 되어야 한다.   
> 즉, 상호 독립, 책임 분리

| 메서드 | 스레드 |
| :-----: | :-----: |
| just | 메인 스레드 |
| from | 메인 스레드 | 
| timer | 메인 스레드와는 다른 스레드 |
| interval | 메인 스레드와는 다른 스레드 |   

* 생산자가 처리 실행 스레드와, 데이터를 받는 측의 스레드를 모두 관리

| 메서드 | 설명 |
| :-----: | :----- |
| subscribeOn | 생산자 스레드 종류 설정 |
| observeOn | 데이터를 처리하는 스레드 종류를 설정 |

##### 스케줄러
* 스케줄러(Scheduler)는 RxJava에서 제공하는 스레드를 관리하는 클래스
* I/O 작업은 대기 시간이 발생할 가능성이 커서 논리 프로세서 수를 초과하여 스레드를 생성하여도 효율적으로 작업이 가능
* 연산 작업은 대기 시간 없이 빠른 처리가 가능하여 논리 프로세서 수를 초과하여 스레드 생성시 스레드 전환 비용이 발생하여 성능 저하
? 스레드 전환 비용

| 메서드 | 스케줄러 |
| :-----: | :----- |
| computation | 연산 처리시 사용, 논리 프로세서 수 만큼 스레드 생성 |
| io | I/O 처리시 사용, 스레드 풀(Thread Pool)로 관리 |
| single | 싱글 스레드 생성 |
| newThread | 매번 새로운 스레드 생성 | 
| from(Executor executor) | 지정한 Executor가 생성한 스레드로 처리 | 
| trampoline | 현재 스레드의 큐(Queue)에 처리 작업을 넣는 스케줄러 |

##### subscribeOn 메서드
* 생산자의 처리 작업을 어떤 스케줄러에서 실행할지 설정하는 메서드
* 최초 1회만 설정하며, 중복 설정시 무시

##### observeOn 메서드
* 데이터를 받는 측의 처리 작업을 어떤 스케줄러에서 실행할지 설정하는 메서드
* 연산자마다 별도의 스케줄러 설정 가능

> observeOn 메서드 인자
> * observeOn(Scheduler scheduler, boolean delayError, int bufferSize)
>   * scheduler : 스레드를 관리하는 스케줄러 클래스
>   * delayError : 에러 통지 시점 설정
>       - true : 모든 데이터를 통지 후 에러통지
>       - false(Default) : 즉시 에러 통지
>   * bufferSize : 통지를 기다리는 데이터 버퍼 크기 (Default : 128)

#### 3.2.2 연산자 내에서 생성되는 비동기 Flowable/Observable
* 연산자 내부에서 Flowable/Observable을 생성하고 그 결과를 통지
* 이때 생성되는 Flowable/Obserable은 별도의 스레드에서 실행
* 순서대로 실행하지만, 별도의 스레드에서 동작하기 때문에 결과 데이터의 순서는 보장되지 않음

##### flatMap 메서드
* 새로운 Flowable/Observable을 생성하고 이를 실행해 통지되는 데이터를 메서드의 결과물로 통지하는 연산자

##### concatMap 메서드
* 새로운 Flowable/Observable을 생성하고 이를 순서대로 실행해 통지되는 데이터를 메서드의 결과물로 통지하는 연산자
* 순서가 보장, 순차 처리 동작

##### concatMapEager
* 새로운 Flowable/Observable을 생성하고 이를 즉시 실행해 통지되는 데이터를 메서드의 결과물로 통지하는 연산자
* 결과 데이터를 버퍼에 담고 있기 때문에 메모리 부족 위험이 있음
* 순서가 보장, 병렬 처리 동작

#### 3.2.3 다른 스레드 간 공유되는 객체
* 여러 소비자가 공유 객체에 접근할 때는 순차적으로 데이터에 접근하지 못하는 이슈
* 여러 Flowable/Obserable을 하나의 Flowable/Observable로 결합하여 순차적으로 공유 객체에 접근하도록 함
* merge 메서드 제공

> Ajax vs React
> * Ajax : Reload 없이 웹 페이지를 refresh하기 위한 기술
> * React : 동적으로 페이지를 업데이트 하기 위한 자바스크립트 라이브러리로 Javascript Interaction 이나 Ajax에 의해 계산 된 컴포넌트를 페이지에 업데이트 (Ajax를 이용하여 페이지 업데이트)
> * Mustache & Handlebars : ReactJS와 약간의 차이가 있으며, 주 목적은 페이지에 보여질 컴포넌트 템플릿을 생성하는 것 (Ajax를 이용하여 데이터를 가져옴)